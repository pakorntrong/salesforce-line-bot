import "core-js/modules/es.error.cause.js";
import "core-js/modules/es.array.push.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.regexp.to-string.js";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$getOwnPropertyDescriptor from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$getOwnPropertyDescriptors from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors";
import _Object$defineProperties from "@babel/runtime-corejs3/core-js-stable/object/define-properties";
import _Object$defineProperty from "@babel/runtime-corejs3/core-js-stable/object/define-property";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";
import _Symbol from "@babel/runtime-corejs3/core-js-stable/symbol";
import _getIteratorMethod from "@babel/runtime-corejs3/core-js/get-iterator-method";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _objectWithoutProperties from "@babel/runtime-corejs3/helpers/objectWithoutProperties";
import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/asyncToGenerator";
var _excluded = ["url", "body"];
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof _Symbol && _getIteratorMethod(r) || r["@@iterator"]; if (!t) { if (_Array$isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { var _context8; if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = _sliceInstanceProperty(_context8 = {}.toString.call(r)).call(_context8, 8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? _Array$from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.regexp.exec.js";
import "core-js/modules/es.regexp.test.js";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import _keysInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/keys";
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context6, _context7; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context6 = ownKeys(Object(t), !0)).call(_context6, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context7 = ownKeys(Object(t))).call(_context7, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
import { Readable } from 'stream';
import fetch, { Response, AbortError } from 'node-fetch';
import createHttpsProxyAgent from 'https-proxy-agent';
import { createHttpRequestHandlerStreams, executeWithTimeout, isRedirect, performRedirectRequest } from './request-helper';
import { getLogger } from './util/logger';
import is from '@sindresorhus/is';

/**
 *
 */
var defaults = {};

/**
 *
 */
export function setDefaults(defaults_) {
  defaults = defaults_;
}

/**
 *
 */
function startFetchRequest(_x, _x2, _x3, _x4, _x5) {
  return _startFetchRequest.apply(this, arguments);
}
/**
 *
 */
function _startFetchRequest() {
  _startFetchRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request, options, input, output, emitter) {
    var _options$retry$status, _options$retry, _options$retry$maxRet, _options$retry2, _options$retry$minTim, _options$retry3, _options$retry$timeou, _options$retry4, _options$retry$errorC, _options$retry5, _options$retry$method, _options$retry6, _options$timeout, _context4;
    var counter,
      logger,
      httpProxy,
      followRedirect,
      agent,
      url,
      body,
      rrequest,
      controller,
      retryCount,
      retryOpts,
      shouldRetryRequest,
      _fetchWithRetries,
      res,
      fetchTimeout,
      headers,
      _iterator,
      _step,
      headerName,
      response,
      _args2 = arguments;
    return _regeneratorRuntime.wrap(function _callee2$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          counter = _args2.length > 5 && _args2[5] !== undefined ? _args2[5] : 0;
          logger = getLogger('fetch');
          httpProxy = options.httpProxy, followRedirect = options.followRedirect;
          agent = httpProxy ? createHttpsProxyAgent(httpProxy) : undefined;
          url = request.url, body = request.body, rrequest = _objectWithoutProperties(request, _excluded);
          controller = new AbortController();
          retryCount = 0;
          retryOpts = {
            statusCodes: (_options$retry$status = (_options$retry = options.retry) === null || _options$retry === void 0 ? void 0 : _options$retry.statusCodes) !== null && _options$retry$status !== void 0 ? _options$retry$status : [420, 429, 500, 502, 503, 504],
            maxRetries: (_options$retry$maxRet = (_options$retry2 = options.retry) === null || _options$retry2 === void 0 ? void 0 : _options$retry2.maxRetries) !== null && _options$retry$maxRet !== void 0 ? _options$retry$maxRet : 5,
            minTimeout: (_options$retry$minTim = (_options$retry3 = options.retry) === null || _options$retry3 === void 0 ? void 0 : _options$retry3.minTimeout) !== null && _options$retry$minTim !== void 0 ? _options$retry$minTim : 500,
            timeoutFactor: (_options$retry$timeou = (_options$retry4 = options.retry) === null || _options$retry4 === void 0 ? void 0 : _options$retry4.timeoutFactor) !== null && _options$retry$timeou !== void 0 ? _options$retry$timeou : 2,
            errorCodes: (_options$retry$errorC = (_options$retry5 = options.retry) === null || _options$retry5 === void 0 ? void 0 : _options$retry5.errorCodes) !== null && _options$retry$errorC !== void 0 ? _options$retry$errorC : ['ECONNRESET', 'ECONNREFUSED', 'ENOTFOUND', 'ENETDOWN', 'ENETUNREACH', 'EHOSTDOWN', 'UND_ERR_SOCKET', 'ETIMEDOUT', 'EPIPE'],
            methods: (_options$retry$method = (_options$retry6 = options.retry) === null || _options$retry6 === void 0 ? void 0 : _options$retry6.methods) !== null && _options$retry$method !== void 0 ? _options$retry$method : ['GET', 'PUT', 'HEAD', 'OPTIONS', 'DELETE']
          };
          shouldRetryRequest = function shouldRetryRequest(maxRetry, resOrErr) {
            var _context;
            if (!_includesInstanceProperty(_context = retryOpts.methods).call(_context, request.method)) return false;
            if (resOrErr instanceof Response) {
              var _context2;
              if (_includesInstanceProperty(_context2 = retryOpts.statusCodes).call(_context2, resOrErr.status)) {
                if (maxRetry === retryCount) {
                  return false;
                } else {
                  return true;
                }
              }
              return false;
            } else {
              var _retryOpts$errorCodes;
              if (maxRetry === retryCount) return false;

              // only retry on operational errors
              // https://github.com/node-fetch/node-fetch/blob/2.x/ERROR-HANDLING.md#error-handling-with-node-fetch
              if (resOrErr.name != 'FetchError') return false;
              if (is.nodeStream(body) && Readable.isDisturbed(body)) {
                logger.debug('Body of type stream was read, unable to retry request.');
                return false;
              }
              if ('code' in resOrErr && resOrErr.code && retryOpts !== null && retryOpts !== void 0 && (_retryOpts$errorCodes = retryOpts.errorCodes) !== null && _retryOpts$errorCodes !== void 0 && _includesInstanceProperty(_retryOpts$errorCodes).call(_retryOpts$errorCodes, resOrErr.code)) return true;
              return false;
            }
          };
          _fetchWithRetries = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
              var maxRetry,
                fetchOpts,
                _res,
                error,
                _args = arguments;
              return _regeneratorRuntime.wrap(function _callee$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    maxRetry = _args.length > 0 && _args[0] !== undefined ? _args[0] : retryOpts === null || retryOpts === void 0 ? void 0 : retryOpts.maxRetries;
                    fetchOpts = _objectSpread(_objectSpread(_objectSpread({}, rrequest), input && /^(post|put|patch)$/i.test(request.method) ? {
                      body: input
                    } : {}), {}, {
                      redirect: 'manual',
                      signal: controller.signal,
                      agent: agent
                    });
                    _context3.prev = 2;
                    _context3.next = 5;
                    return fetch(url, fetchOpts);
                  case 5:
                    _res = _context3.sent;
                    if (!shouldRetryRequest(retryOpts.maxRetries, _res)) {
                      _context3.next = 16;
                      break;
                    }
                    logger.debug("retrying for the ".concat(retryCount + 1, " time"));
                    logger.debug('reason: statusCode match');
                    _context3.next = 11;
                    return sleep(retryCount === 0 ? retryOpts.minTimeout : retryOpts.minTimeout * Math.pow(retryOpts.timeoutFactor, retryCount));
                  case 11:
                    // NOTE: this event is only used by tests and will be removed at any time.
                    // jsforce may switch to node's fetch which doesn't emit this event on retries.
                    emitter.emit('retry', retryCount);
                    retryCount++;
                    _context3.next = 15;
                    return _fetchWithRetries(maxRetry);
                  case 15:
                    return _context3.abrupt("return", _context3.sent);
                  case 16:
                    return _context3.abrupt("return", _res);
                  case 19:
                    _context3.prev = 19;
                    _context3.t0 = _context3["catch"](2);
                    logger.debug('Request failed');
                    error = _context3.t0; // request was canceled by consumer (AbortController), skip retry and rethrow.
                    if (!(error.name === 'AbortError')) {
                      _context3.next = 25;
                      break;
                    }
                    throw error;
                  case 25:
                    if (!shouldRetryRequest(retryOpts.maxRetries, error)) {
                      _context3.next = 33;
                      break;
                    }
                    logger.debug("retrying for the ".concat(retryCount + 1, " time"));
                    logger.debug("Error: ".concat(_context3.t0.message));
                    _context3.next = 30;
                    return sleep(retryCount === 0 ? retryOpts.minTimeout : retryOpts.minTimeout * Math.pow(retryOpts.timeoutFactor, retryCount));
                  case 30:
                    // NOTE: this event is only used by tests and will be removed at any time.
                    // jsforce may switch to node's fetch which doesn't emit this event on retries.
                    emitter.emit('retry', retryCount);
                    retryCount++;
                    return _context3.abrupt("return", _fetchWithRetries(maxRetry));
                  case 33:
                    logger.debug('Skipping retry...');
                    if (!(maxRetry === retryCount)) {
                      _context3.next = 38;
                      break;
                    }
                    throw _context3.t0;
                  case 38:
                    throw _context3.t0;
                  case 39:
                  case "end":
                    return _context3.stop();
                }
              }, _callee, null, [[2, 19]]);
            }));
            return function fetchWithRetries() {
              return _ref.apply(this, arguments);
            };
          }();
          // Timeout after 30 minutes without a response
          //
          // node-fetch's default timeout is 0 and jsforce consumers can't set this when calling `Connection` methods so we set a long default at the fetch wrapper level.
          fetchTimeout = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : 1800000;
          _context5.prev = 11;
          _context5.next = 14;
          return executeWithTimeout(_fetchWithRetries, fetchTimeout, function () {
            return controller.abort();
          });
        case 14:
          res = _context5.sent;
          _context5.next = 22;
          break;
        case 17:
          _context5.prev = 17;
          _context5.t0 = _context5["catch"](11);
          if (_context5.t0 instanceof AbortError) {
            _context5.t0.message += ' Request was aborted due to timeout of 10 minutes.';
          }
          emitter.emit('error', _context5.t0);
          return _context5.abrupt("return");
        case 22:
          headers = {};
          _iterator = _createForOfIteratorHelper(_keysInstanceProperty(_context4 = res.headers).call(_context4));
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              headerName = _step.value;
              headers[headerName.toLowerCase()] = res.headers.get(headerName);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          response = {
            statusCode: res.status,
            headers: headers
          };
          if (!(followRedirect && isRedirect(response.statusCode))) {
            _context5.next = 29;
            break;
          }
          try {
            performRedirectRequest(request, response, followRedirect, counter, function (req) {
              return startFetchRequest(req, options, undefined, output, emitter, counter + 1);
            });
          } catch (err) {
            emitter.emit('error', err);
          }
          return _context5.abrupt("return");
        case 29:
          emitter.emit('response', response);
          res.body.pipe(output);
        case 31:
        case "end":
          return _context5.stop();
      }
    }, _callee2, null, [[11, 17]]);
  }));
  return _startFetchRequest.apply(this, arguments);
}
export default function request(req) {
  var options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = _objectSpread(_objectSpread({}, defaults), options_);
  var _createHttpRequestHan = createHttpRequestHandlerStreams(req, options),
    input = _createHttpRequestHan.input,
    output = _createHttpRequestHan.output,
    stream = _createHttpRequestHan.stream;
  startFetchRequest(req, options, input, output, stream);
  return stream;
}
var sleep = function sleep(ms) {
  return new _Promise(function (r) {
    return _setTimeout(r, ms);
  });
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSZWFkYWJsZSIsImZldGNoIiwiUmVzcG9uc2UiLCJBYm9ydEVycm9yIiwiY3JlYXRlSHR0cHNQcm94eUFnZW50IiwiY3JlYXRlSHR0cFJlcXVlc3RIYW5kbGVyU3RyZWFtcyIsImV4ZWN1dGVXaXRoVGltZW91dCIsImlzUmVkaXJlY3QiLCJwZXJmb3JtUmVkaXJlY3RSZXF1ZXN0IiwiZ2V0TG9nZ2VyIiwiaXMiLCJkZWZhdWx0cyIsInNldERlZmF1bHRzIiwiZGVmYXVsdHNfIiwic3RhcnRGZXRjaFJlcXVlc3QiLCJfeCIsIl94MiIsIl94MyIsIl94NCIsIl94NSIsIl9zdGFydEZldGNoUmVxdWVzdCIsImFwcGx5IiwiYXJndW1lbnRzIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJfcmVnZW5lcmF0b3JSdW50aW1lIiwibWFyayIsIl9jYWxsZWUyIiwicmVxdWVzdCIsIm9wdGlvbnMiLCJpbnB1dCIsIm91dHB1dCIsImVtaXR0ZXIiLCJfb3B0aW9ucyRyZXRyeSRzdGF0dXMiLCJfb3B0aW9ucyRyZXRyeSIsIl9vcHRpb25zJHJldHJ5JG1heFJldCIsIl9vcHRpb25zJHJldHJ5MiIsIl9vcHRpb25zJHJldHJ5JG1pblRpbSIsIl9vcHRpb25zJHJldHJ5MyIsIl9vcHRpb25zJHJldHJ5JHRpbWVvdSIsIl9vcHRpb25zJHJldHJ5NCIsIl9vcHRpb25zJHJldHJ5JGVycm9yQyIsIl9vcHRpb25zJHJldHJ5NSIsIl9vcHRpb25zJHJldHJ5JG1ldGhvZCIsIl9vcHRpb25zJHJldHJ5NiIsIl9vcHRpb25zJHRpbWVvdXQiLCJfY29udGV4dDQiLCJjb3VudGVyIiwibG9nZ2VyIiwiaHR0cFByb3h5IiwiZm9sbG93UmVkaXJlY3QiLCJhZ2VudCIsInVybCIsImJvZHkiLCJycmVxdWVzdCIsImNvbnRyb2xsZXIiLCJyZXRyeUNvdW50IiwicmV0cnlPcHRzIiwic2hvdWxkUmV0cnlSZXF1ZXN0IiwiX2ZldGNoV2l0aFJldHJpZXMiLCJyZXMiLCJmZXRjaFRpbWVvdXQiLCJoZWFkZXJzIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJoZWFkZXJOYW1lIiwicmVzcG9uc2UiLCJfYXJnczIiLCJ3cmFwIiwiX2NhbGxlZTIkIiwiX2NvbnRleHQ1IiwicHJldiIsIm5leHQiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJfZXhjbHVkZWQiLCJBYm9ydENvbnRyb2xsZXIiLCJzdGF0dXNDb2RlcyIsInJldHJ5IiwibWF4UmV0cmllcyIsIm1pblRpbWVvdXQiLCJ0aW1lb3V0RmFjdG9yIiwiZXJyb3JDb2RlcyIsIm1ldGhvZHMiLCJtYXhSZXRyeSIsInJlc09yRXJyIiwiX2NvbnRleHQiLCJfaW5jbHVkZXNJbnN0YW5jZVByb3BlcnR5IiwiY2FsbCIsIm1ldGhvZCIsIl9jb250ZXh0MiIsInN0YXR1cyIsIl9yZXRyeU9wdHMkZXJyb3JDb2RlcyIsIm5hbWUiLCJub2RlU3RyZWFtIiwiaXNEaXN0dXJiZWQiLCJkZWJ1ZyIsImNvZGUiLCJmZXRjaFdpdGhSZXRyaWVzIiwiX3JlZiIsIl9jYWxsZWUiLCJmZXRjaE9wdHMiLCJfcmVzIiwiZXJyb3IiLCJfYXJncyIsIl9jYWxsZWUkIiwiX2NvbnRleHQzIiwiX29iamVjdFNwcmVhZCIsInRlc3QiLCJyZWRpcmVjdCIsInNpZ25hbCIsInNlbnQiLCJjb25jYXQiLCJzbGVlcCIsIk1hdGgiLCJwb3ciLCJlbWl0IiwiYWJydXB0IiwidDAiLCJtZXNzYWdlIiwic3RvcCIsInRpbWVvdXQiLCJhYm9ydCIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiX2tleXNJbnN0YW5jZVByb3BlcnR5IiwicyIsIm4iLCJkb25lIiwidmFsdWUiLCJ0b0xvd2VyQ2FzZSIsImdldCIsImVyciIsImUiLCJmIiwic3RhdHVzQ29kZSIsInJlcSIsInBpcGUiLCJvcHRpb25zXyIsIl9jcmVhdGVIdHRwUmVxdWVzdEhhbiIsInN0cmVhbSIsIm1zIiwiX1Byb21pc2UiLCJyIiwiX3NldFRpbWVvdXQiXSwic291cmNlcyI6WyIuLi9zcmMvcmVxdWVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgRHVwbGV4LCBSZWFkYWJsZSwgV3JpdGFibGUgfSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IGZldGNoLCB7IFJlc3BvbnNlLCBSZXF1ZXN0SW5pdCwgRmV0Y2hFcnJvciwgQWJvcnRFcnJvciB9IGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IGNyZWF0ZUh0dHBzUHJveHlBZ2VudCBmcm9tICdodHRwcy1wcm94eS1hZ2VudCc7XG5pbXBvcnQge1xuICBjcmVhdGVIdHRwUmVxdWVzdEhhbmRsZXJTdHJlYW1zLFxuICBleGVjdXRlV2l0aFRpbWVvdXQsXG4gIGlzUmVkaXJlY3QsXG4gIHBlcmZvcm1SZWRpcmVjdFJlcXVlc3QsXG59IGZyb20gJy4vcmVxdWVzdC1oZWxwZXInO1xuaW1wb3J0IHsgSHR0cFJlcXVlc3QsIEh0dHBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi91dGlsL2xvZ2dlcic7XG5pbXBvcnQgaXMgZnJvbSAnQHNpbmRyZXNvcmh1cy9pcyc7XG5cbi8qKlxuICpcbiAqL1xubGV0IGRlZmF1bHRzOiBIdHRwUmVxdWVzdE9wdGlvbnMgPSB7fTtcblxuLyoqXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVmYXVsdHMoZGVmYXVsdHNfOiBIdHRwUmVxdWVzdE9wdGlvbnMpIHtcbiAgZGVmYXVsdHMgPSBkZWZhdWx0c187XG59XG5cbi8qKlxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3RhcnRGZXRjaFJlcXVlc3QoXG4gIHJlcXVlc3Q6IEh0dHBSZXF1ZXN0LFxuICBvcHRpb25zOiBIdHRwUmVxdWVzdE9wdGlvbnMsXG4gIGlucHV0OiBSZWFkYWJsZSB8IHVuZGVmaW5lZCxcbiAgb3V0cHV0OiBXcml0YWJsZSxcbiAgZW1pdHRlcjogRXZlbnRFbWl0dGVyLFxuICBjb3VudGVyOiBudW1iZXIgPSAwLFxuKSB7XG4gIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcignZmV0Y2gnKTtcbiAgY29uc3QgeyBodHRwUHJveHksIGZvbGxvd1JlZGlyZWN0IH0gPSBvcHRpb25zO1xuICBjb25zdCBhZ2VudCA9IGh0dHBQcm94eSA/IGNyZWF0ZUh0dHBzUHJveHlBZ2VudChodHRwUHJveHkpIDogdW5kZWZpbmVkO1xuICBjb25zdCB7IHVybCwgYm9keSwgLi4ucnJlcXVlc3QgfSA9IHJlcXVlc3Q7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgbGV0IHJldHJ5Q291bnQgPSAwO1xuXG4gIGNvbnN0IHJldHJ5T3B0czogUmVxdWlyZWQ8SHR0cFJlcXVlc3RPcHRpb25zWydyZXRyeSddPiA9IHtcbiAgICBzdGF0dXNDb2Rlczogb3B0aW9ucy5yZXRyeT8uc3RhdHVzQ29kZXMgPz8gWzQyMCwgNDI5LCA1MDAsIDUwMiwgNTAzLCA1MDRdLFxuICAgIG1heFJldHJpZXM6IG9wdGlvbnMucmV0cnk/Lm1heFJldHJpZXMgPz8gNSxcbiAgICBtaW5UaW1lb3V0OiBvcHRpb25zLnJldHJ5Py5taW5UaW1lb3V0ID8/IDUwMCxcbiAgICB0aW1lb3V0RmFjdG9yOiBvcHRpb25zLnJldHJ5Py50aW1lb3V0RmFjdG9yID8/IDIsXG4gICAgZXJyb3JDb2Rlczogb3B0aW9ucy5yZXRyeT8uZXJyb3JDb2RlcyA/PyBbXG4gICAgICAnRUNPTk5SRVNFVCcsXG4gICAgICAnRUNPTk5SRUZVU0VEJyxcbiAgICAgICdFTk9URk9VTkQnLFxuICAgICAgJ0VORVRET1dOJyxcbiAgICAgICdFTkVUVU5SRUFDSCcsXG4gICAgICAnRUhPU1RET1dOJyxcbiAgICAgICdVTkRfRVJSX1NPQ0tFVCcsXG4gICAgICAnRVRJTUVET1VUJyxcbiAgICAgICdFUElQRScsXG4gICAgXSxcbiAgICBtZXRob2RzOiBvcHRpb25zLnJldHJ5Py5tZXRob2RzID8/IFtcbiAgICAgICdHRVQnLFxuICAgICAgJ1BVVCcsXG4gICAgICAnSEVBRCcsXG4gICAgICAnT1BUSU9OUycsXG4gICAgICAnREVMRVRFJyxcbiAgICBdLFxuICB9O1xuXG4gIGNvbnN0IHNob3VsZFJldHJ5UmVxdWVzdCA9IChcbiAgICBtYXhSZXRyeTogbnVtYmVyLFxuICAgIHJlc09yRXJyOiBSZXNwb25zZSB8IEVycm9yIHwgRmV0Y2hFcnJvcixcbiAgKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFyZXRyeU9wdHMubWV0aG9kcy5pbmNsdWRlcyhyZXF1ZXN0Lm1ldGhvZCkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChyZXNPckVyciBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICBpZiAocmV0cnlPcHRzLnN0YXR1c0NvZGVzLmluY2x1ZGVzKHJlc09yRXJyLnN0YXR1cykpIHtcbiAgICAgICAgaWYgKG1heFJldHJ5ID09PSByZXRyeUNvdW50KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1heFJldHJ5ID09PSByZXRyeUNvdW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIG9ubHkgcmV0cnkgb24gb3BlcmF0aW9uYWwgZXJyb3JzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2Jsb2IvMi54L0VSUk9SLUhBTkRMSU5HLm1kI2Vycm9yLWhhbmRsaW5nLXdpdGgtbm9kZS1mZXRjaFxuICAgICAgaWYgKHJlc09yRXJyLm5hbWUgIT0gJ0ZldGNoRXJyb3InKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGlmIChpcy5ub2RlU3RyZWFtKGJvZHkpICYmIFJlYWRhYmxlLmlzRGlzdHVyYmVkKGJvZHkpKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnQm9keSBvZiB0eXBlIHN0cmVhbSB3YXMgcmVhZCwgdW5hYmxlIHRvIHJldHJ5IHJlcXVlc3QuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAnY29kZScgaW4gcmVzT3JFcnIgJiZcbiAgICAgICAgcmVzT3JFcnIuY29kZSAmJlxuICAgICAgICByZXRyeU9wdHM/LmVycm9yQ29kZXM/LmluY2x1ZGVzKHJlc09yRXJyLmNvZGUpXG4gICAgICApXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGZldGNoV2l0aFJldHJpZXMgPSBhc3luYyAoXG4gICAgbWF4UmV0cnkgPSByZXRyeU9wdHM/Lm1heFJldHJpZXMsXG4gICk6IFByb21pc2U8UmVzcG9uc2U+ID0+IHtcbiAgICBjb25zdCBmZXRjaE9wdHM6IFJlcXVlc3RJbml0ID0ge1xuICAgICAgLi4ucnJlcXVlc3QsXG4gICAgICAuLi4oaW5wdXQgJiYgL14ocG9zdHxwdXR8cGF0Y2gpJC9pLnRlc3QocmVxdWVzdC5tZXRob2QpXG4gICAgICAgID8geyBib2R5OiBpbnB1dCB9XG4gICAgICAgIDoge30pLFxuICAgICAgcmVkaXJlY3Q6ICdtYW51YWwnLFxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIGFnZW50LFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCBmZXRjaE9wdHMpO1xuICAgICAgaWYgKHNob3VsZFJldHJ5UmVxdWVzdChyZXRyeU9wdHMubWF4UmV0cmllcywgcmVzKSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYHJldHJ5aW5nIGZvciB0aGUgJHtyZXRyeUNvdW50ICsgMX0gdGltZWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlYXNvbjogc3RhdHVzQ29kZSBtYXRjaCcpO1xuXG4gICAgICAgIGF3YWl0IHNsZWVwKFxuICAgICAgICAgIHJldHJ5Q291bnQgPT09IDBcbiAgICAgICAgICAgID8gcmV0cnlPcHRzLm1pblRpbWVvdXRcbiAgICAgICAgICAgIDogcmV0cnlPcHRzLm1pblRpbWVvdXQgKiByZXRyeU9wdHMudGltZW91dEZhY3RvciAqKiByZXRyeUNvdW50LFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIE5PVEU6IHRoaXMgZXZlbnQgaXMgb25seSB1c2VkIGJ5IHRlc3RzIGFuZCB3aWxsIGJlIHJlbW92ZWQgYXQgYW55IHRpbWUuXG4gICAgICAgIC8vIGpzZm9yY2UgbWF5IHN3aXRjaCB0byBub2RlJ3MgZmV0Y2ggd2hpY2ggZG9lc24ndCBlbWl0IHRoaXMgZXZlbnQgb24gcmV0cmllcy5cbiAgICAgICAgZW1pdHRlci5lbWl0KCdyZXRyeScsIHJldHJ5Q291bnQpO1xuICAgICAgICByZXRyeUNvdW50Kys7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGZldGNoV2l0aFJldHJpZXMobWF4UmV0cnkpO1xuICAgICAgfVxuICAgICAgLy8gc2hvdWxkIHdlIHRocm93IGhlcmUgaWYgdGhlIG1heFJldHJ5IGFscmVhZHkgaGFwcGVuZWQgYW5kIHN0aWxsIGdvdCB0aGUgc2FtZSBzdGF0dXNDb2RlP1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnUmVxdWVzdCBmYWlsZWQnKTtcbiAgICAgIGNvbnN0IGVycm9yID0gZXJyIGFzIEVycm9yIHwgRmV0Y2hFcnJvcjtcblxuICAgICAgLy8gcmVxdWVzdCB3YXMgY2FuY2VsZWQgYnkgY29uc3VtZXIgKEFib3J0Q29udHJvbGxlciksIHNraXAgcmV0cnkgYW5kIHJldGhyb3cuXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUmV0cnlSZXF1ZXN0KHJldHJ5T3B0cy5tYXhSZXRyaWVzLCBlcnJvcikpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGByZXRyeWluZyBmb3IgdGhlICR7cmV0cnlDb3VudCArIDF9IHRpbWVgKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBFcnJvcjogJHsoZXJyIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuXG4gICAgICAgIGF3YWl0IHNsZWVwKFxuICAgICAgICAgIHJldHJ5Q291bnQgPT09IDBcbiAgICAgICAgICAgID8gcmV0cnlPcHRzLm1pblRpbWVvdXRcbiAgICAgICAgICAgIDogcmV0cnlPcHRzLm1pblRpbWVvdXQgKiByZXRyeU9wdHMudGltZW91dEZhY3RvciAqKiByZXRyeUNvdW50LFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIE5PVEU6IHRoaXMgZXZlbnQgaXMgb25seSB1c2VkIGJ5IHRlc3RzIGFuZCB3aWxsIGJlIHJlbW92ZWQgYXQgYW55IHRpbWUuXG4gICAgICAgIC8vIGpzZm9yY2UgbWF5IHN3aXRjaCB0byBub2RlJ3MgZmV0Y2ggd2hpY2ggZG9lc24ndCBlbWl0IHRoaXMgZXZlbnQgb24gcmV0cmllcy5cbiAgICAgICAgZW1pdHRlci5lbWl0KCdyZXRyeScsIHJldHJ5Q291bnQpO1xuICAgICAgICByZXRyeUNvdW50Kys7XG5cbiAgICAgICAgcmV0dXJuIGZldGNoV2l0aFJldHJpZXMobWF4UmV0cnkpO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIuZGVidWcoJ1NraXBwaW5nIHJldHJ5Li4uJyk7XG5cbiAgICAgIGlmIChtYXhSZXRyeSA9PT0gcmV0cnlDb3VudCkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGxldCByZXM6IFJlc3BvbnNlO1xuXG4gIC8vIFRpbWVvdXQgYWZ0ZXIgMzAgbWludXRlcyB3aXRob3V0IGEgcmVzcG9uc2VcbiAgLy9cbiAgLy8gbm9kZS1mZXRjaCdzIGRlZmF1bHQgdGltZW91dCBpcyAwIGFuZCBqc2ZvcmNlIGNvbnN1bWVycyBjYW4ndCBzZXQgdGhpcyB3aGVuIGNhbGxpbmcgYENvbm5lY3Rpb25gIG1ldGhvZHMgc28gd2Ugc2V0IGEgbG9uZyBkZWZhdWx0IGF0IHRoZSBmZXRjaCB3cmFwcGVyIGxldmVsLlxuICBjb25zdCBmZXRjaFRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgPz8gMV84MDBfMDAwO1xuXG4gIHRyeSB7XG4gICAgcmVzID0gYXdhaXQgZXhlY3V0ZVdpdGhUaW1lb3V0KGZldGNoV2l0aFJldHJpZXMsIGZldGNoVGltZW91dCwgKCkgPT5cbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKSxcbiAgICApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgQWJvcnRFcnJvcikge1xuICAgICAgKGVyciBhcyBFcnJvcikubWVzc2FnZSArPSAnIFJlcXVlc3Qgd2FzIGFib3J0ZWQgZHVlIHRvIHRpbWVvdXQgb2YgMTAgbWludXRlcy4nO1xuICAgIH1cbiAgICBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICBmb3IgKGNvbnN0IGhlYWRlck5hbWUgb2YgcmVzLmhlYWRlcnMua2V5cygpKSB7XG4gICAgaGVhZGVyc1toZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCldID0gcmVzLmhlYWRlcnMuZ2V0KGhlYWRlck5hbWUpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXMsXG4gICAgaGVhZGVycyxcbiAgfTtcbiAgaWYgKGZvbGxvd1JlZGlyZWN0ICYmIGlzUmVkaXJlY3QocmVzcG9uc2Uuc3RhdHVzQ29kZSkpIHtcbiAgICB0cnkge1xuICAgICAgcGVyZm9ybVJlZGlyZWN0UmVxdWVzdChcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGZvbGxvd1JlZGlyZWN0LFxuICAgICAgICBjb3VudGVyLFxuICAgICAgICAocmVxKSA9PlxuICAgICAgICAgIHN0YXJ0RmV0Y2hSZXF1ZXN0KFxuICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgIGVtaXR0ZXIsXG4gICAgICAgICAgICBjb3VudGVyICsgMSxcbiAgICAgICAgICApLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZW1pdHRlci5lbWl0KCdyZXNwb25zZScsIHJlc3BvbnNlKTtcbiAgcmVzLmJvZHkucGlwZShvdXRwdXQpO1xufVxuXG4vKipcbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcXVlc3QoXG4gIHJlcTogSHR0cFJlcXVlc3QsXG4gIG9wdGlvbnNfOiBIdHRwUmVxdWVzdE9wdGlvbnMgPSB7fSxcbik6IER1cGxleCB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7IC4uLmRlZmF1bHRzLCAuLi5vcHRpb25zXyB9O1xuICBjb25zdCB7IGlucHV0LCBvdXRwdXQsIHN0cmVhbSB9ID0gY3JlYXRlSHR0cFJlcXVlc3RIYW5kbGVyU3RyZWFtcyhcbiAgICByZXEsXG4gICAgb3B0aW9ucyxcbiAgKTtcbiAgc3RhcnRGZXRjaFJlcXVlc3QocmVxLCBvcHRpb25zLCBpbnB1dCwgb3V0cHV0LCBzdHJlYW0pO1xuICByZXR1cm4gc3RyZWFtO1xufVxuXG5jb25zdCBzbGVlcCA9IChtczogbnVtYmVyKSA9PiBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCBtcykpO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsU0FBaUJBLFFBQVEsUUFBa0IsUUFBUTtBQUNuRCxPQUFPQyxLQUFLLElBQUlDLFFBQVEsRUFBMkJDLFVBQVUsUUFBUSxZ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